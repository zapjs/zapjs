/**
 * Route tree code generator
 *
 * Generates TypeScript files for:
 * - routeTree.ts - Route definitions and type-safe paths
 * - routeManifest.json - JSON manifest for Rust server
 * - routerConfig.ts - Client-side router configuration
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, relative, dirname } from 'path';
import type {
  RouteTree,
  ScannedRoute,
  CodegenOptions,
  RouteManifest,
  RouteParam,
  WebSocketRoute,
  LayoutRoute,
} from './types.js';

/**
 * Generate route tree TypeScript file and manifest
 */
export function generateRouteTree(options: CodegenOptions): void {
  const { outputDir, routeTree } = options;

  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Generate TypeScript route tree
  const tsContent = generateTypeScriptRouteTree(routeTree, outputDir);
  writeFileSync(join(outputDir, 'routeTree.ts'), tsContent);

  // Generate JSON manifest for Rust
  const manifest = generateManifest(routeTree);
  writeFileSync(join(outputDir, 'routeManifest.json'), JSON.stringify(manifest, null, 2));

  // Generate client router configuration
  const routerConfig = generateRouterConfig(routeTree, outputDir);
  writeFileSync(join(outputDir, 'routerConfig.ts'), routerConfig);
}

function generateTypeScriptRouteTree(tree: RouteTree, outputDir: string): string {
  // Check if any routes have special components
  const hasAnyErrorComponents = tree.routes.some((r) => r.hasErrorComponent);
  const hasAnyPendingComponents = tree.routes.some((r) => r.hasPendingComponent);
  const hasAnyMeta = tree.routes.some((r) => r.hasMeta);

  const lines: string[] = [
    '/**',
    ' * Auto-generated by @zapjs/router',
    ' * DO NOT EDIT MANUALLY',
    ' */',
    '',
    "import { lazy } from 'react';",
  ];

  // Import ErrorBoundary if any routes have error components
  if (hasAnyErrorComponents) {
    lines.push("import { ErrorBoundary } from '@zapjs/runtime';");
  }
  lines.push('');

  // Generate layout imports
  if (tree.layouts.length > 0) {
    lines.push('// Layout component imports');
    const layoutImports = generateLayoutImports(tree.layouts, outputDir);
    lines.push(...layoutImports);
    lines.push('');
  }

  // Generate route imports
  lines.push('// Route component imports');
  const imports = generateRouteImports(tree.routes, outputDir);
  lines.push(...imports);
  lines.push('');

  // Generate route path types
  lines.push('// Route path type definitions');
  lines.push(generatePathTypes(tree));
  lines.push('');

  // Generate layout config
  if (tree.layouts.length > 0) {
    lines.push('// Layout configuration');
    lines.push(generateLayoutConfig(tree, outputDir));
    lines.push('');
  }

  // Generate route config
  lines.push('// Route configuration');
  lines.push(generateRouteConfig(tree, outputDir));
  lines.push('');

  // Generate API route config
  if (tree.apiRoutes.length > 0) {
    lines.push('// API route configuration');
    lines.push(generateApiRouteConfig(tree));
    lines.push('');
  }

  // Generate WebSocket route config
  if (tree.wsRoutes.length > 0) {
    lines.push('// WebSocket route configuration');
    lines.push(generateWsRouteConfig(tree));
    lines.push('');
  }

  // Generate helper functions
  lines.push('// Helper functions');
  lines.push(generateHelpers(tree));

  return lines.join('\n');
}

function generateLayoutImports(layouts: LayoutRoute[], outputDir: string): string[] {
  const lines: string[] = [];

  for (const layout of layouts) {
    const varName = layoutToVarName(layout);
    const relativePath = getRelativeImportPath(outputDir, layout.filePath);
    lines.push(`const ${varName} = lazy(() => import('${relativePath}'));`);
  }

  return lines;
}

function generateRouteImports(routes: ScannedRoute[], outputDir: string): string[] {
  const lines: string[] = [];

  for (const route of routes) {
    if (route.type !== 'page') continue;

    const varName = routeToVarName(route);
    const relativePath = getRelativeImportPath(outputDir, route.filePath);

    // Main component import
    lines.push(`const ${varName} = lazy(() => import('${relativePath}'));`);

    // Error component import (if route has one)
    if (route.hasErrorComponent) {
      const errorVarName = routeToErrorVarName(route);
      const exportName = route.errorComponentExport || 'errorComponent';
      lines.push(
        `const ${errorVarName} = lazy(() => import('${relativePath}').then(m => ({ default: m.${exportName} })));`
      );
    }

    // Pending component import (if route has one)
    if (route.hasPendingComponent) {
      const pendingVarName = routeToPendingVarName(route);
      const exportName = route.pendingComponentExport || 'pendingComponent';
      lines.push(
        `const ${pendingVarName} = lazy(() => import('${relativePath}').then(m => ({ default: m.${exportName} })));`
      );
    }

    // Meta import (if route has one)
    if (route.hasMeta) {
      const metaVarName = routeToMetaVarName(route);
      lines.push(
        `const ${metaVarName} = () => import('${relativePath}').then(m => m.meta);`
      );
    }

    // Middleware import (if route has one)
    if (route.hasMiddleware) {
      const middlewareVarName = routeToMiddlewareVarName(route);
      lines.push(
        `const ${middlewareVarName} = () => import('${relativePath}').then(m => m.middleware);`
      );
    }
  }

  return lines;
}

function generatePathTypes(tree: RouteTree): string {
  const allRoutes = [...tree.routes, ...tree.apiRoutes];
  const wsPaths = tree.wsRoutes.map((r) => `  | '${r.urlPath}'`);
  const paths = allRoutes.map((r) => `  | '${r.urlPath}'`);

  let result = `export type RoutePath =\n${paths.join('\n')};`;

  if (wsPaths.length > 0) {
    result += `\n\nexport type WebSocketPath =\n${wsPaths.join('\n')};`;
  }

  return result;
}

function generateLayoutConfig(tree: RouteTree, outputDir: string): string {
  const lines: string[] = ['export const layouts = ['];

  for (const layout of tree.layouts) {
    const varName = layoutToVarName(layout);

    lines.push('  {');
    lines.push(`    path: '${layout.urlPath}',`);
    lines.push(`    scopePath: '${layout.scopePath}',`);
    lines.push(`    component: ${varName},`);
    if (layout.parentLayout) {
      const parentLayout = tree.layouts.find(l => l.filePath === layout.parentLayout);
      if (parentLayout) {
        lines.push(`    parentLayout: '${parentLayout.urlPath}',`);
      }
    }
    lines.push('  },');
  }

  lines.push('] as const;');
  return lines.join('\n');
}

function generateRouteConfig(tree: RouteTree, outputDir: string): string {
  const lines: string[] = ['export const routes = ['];

  for (const route of tree.routes) {
    if (route.type !== 'page') continue;

    const varName = routeToVarName(route);

    lines.push('  {');
    lines.push(`    path: '${route.urlPath}',`);
    lines.push(`    component: ${varName},`);
    lines.push(`    isIndex: ${route.isIndex},`);

    if (route.params.length > 0) {
      // Include full param info with optional flag
      const paramInfo = route.params.map((p) => ({
        name: p.name,
        optional: p.optional,
        catchAll: p.catchAll,
      }));
      lines.push(`    params: ${JSON.stringify(paramInfo)},`);
    }

    // Add priority
    if (route.priority !== undefined) {
      lines.push(`    priority: ${route.priority},`);
    }

    // Add layout path if route has a parent layout
    if (route.layoutPath) {
      const layout = tree.layouts.find(l => l.filePath === route.layoutPath);
      if (layout) {
        lines.push(`    layoutPath: '${layout.urlPath}',`);
      }
    }

    // Add error component reference (TanStack style)
    if (route.hasErrorComponent) {
      const errorVarName = routeToErrorVarName(route);
      lines.push(`    errorComponent: ${errorVarName},`);
    }

    // Add pending component reference
    if (route.hasPendingComponent) {
      const pendingVarName = routeToPendingVarName(route);
      lines.push(`    pendingComponent: ${pendingVarName},`);
    }

    // Add meta loader reference
    if (route.hasMeta) {
      const metaVarName = routeToMetaVarName(route);
      lines.push(`    meta: ${metaVarName},`);
    }

    // Add middleware loader reference
    if (route.hasMiddleware) {
      const middlewareVarName = routeToMiddlewareVarName(route);
      lines.push(`    middleware: ${middlewareVarName},`);
    }

    lines.push('  },');
  }

  lines.push('] as const;');
  return lines.join('\n');
}

function generateApiRouteConfig(tree: RouteTree): string {
  const lines: string[] = ['export const apiRoutes = ['];

  for (const route of tree.apiRoutes) {
    lines.push('  {');
    lines.push(`    path: '${route.urlPath}',`);
    lines.push(`    filePath: '${route.relativePath}',`);
    lines.push(`    isIndex: ${route.isIndex},`);
    lines.push(`    methods: ${JSON.stringify(route.methods || ['GET'])},`);

    if (route.params.length > 0) {
      const paramInfo = route.params.map((p) => ({
        name: p.name,
        optional: p.optional,
        catchAll: p.catchAll,
      }));
      lines.push(`    params: ${JSON.stringify(paramInfo)},`);
    }

    if (route.priority !== undefined) {
      lines.push(`    priority: ${route.priority},`);
    }

    if (route.hasMiddleware) {
      lines.push(`    hasMiddleware: true,`);
    }

    lines.push('  },');
  }

  lines.push('] as const;');
  return lines.join('\n');
}

function generateWsRouteConfig(tree: RouteTree): string {
  const lines: string[] = ['export const wsRoutes = ['];

  for (const route of tree.wsRoutes) {
    lines.push('  {');
    lines.push(`    path: '${route.urlPath}',`);
    lines.push(`    filePath: '${route.relativePath}',`);

    if (route.params.length > 0) {
      const paramInfo = route.params.map((p) => ({
        name: p.name,
        optional: p.optional,
        catchAll: p.catchAll,
      }));
      lines.push(`    params: ${JSON.stringify(paramInfo)},`);
    }

    lines.push('  },');
  }

  lines.push('] as const;');
  return lines.join('\n');
}

function generateHelpers(tree: RouteTree): string {
  const allRoutes = [...tree.routes, ...tree.apiRoutes];

  // Build path helper function generators
  const pathHelpers: string[] = [];

  for (const route of allRoutes) {
    if (route.params.length === 0) continue;

    const fnName = urlPathToFunctionName(route.urlPath);

    // Handle optional params with ? suffix in type
    const params = route.params.map((p) => {
      const optional = p.optional ? '?' : '';
      return `${p.name}${optional}: string`;
    }).join(', ');

    let template = route.urlPath;
    for (const param of route.params) {
      const optionalMarker = param.optional ? '?' : '';
      if (param.catchAll) {
        template = template.replace(`*${param.name}${optionalMarker}`, `\${${param.name} || ''}`);
      } else {
        template = template.replace(`:${param.name}${optionalMarker}`, `\${${param.name} || ''}`);
      }
    }

    pathHelpers.push(`export function ${fnName}(${params}): string {`);
    pathHelpers.push(`  return \`${template}\`.replace(/\\/+$/, '') || '/';`);
    pathHelpers.push('}');
    pathHelpers.push('');
  }

  return pathHelpers.join('\n');
}

function generateManifest(tree: RouteTree): RouteManifest {
  return {
    version: '1.0.0',
    generatedAt: new Date().toISOString(),
    routes: tree.routes.map((r) => ({
      ...r,
      // Remove absolute paths for security
      filePath: r.relativePath,
    })),
    apiRoutes: tree.apiRoutes.map((r) => ({
      ...r,
      filePath: r.relativePath,
    })),
  };
}

function routeToVarName(route: ScannedRoute): string {
  // Convert path like /posts/:postId to PostsPostIdRoute
  // Also handles [param] style (e.g., /blog/[slug] -> BlogSlugRoute)
  let name = route.urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_')
    .replace(/\?/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'Index';

  // PascalCase
  name = name
    .split('_')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}Route`;
}

function routeToErrorVarName(route: ScannedRoute): string {
  // Convert path like /posts/:postId to PostsPostIdErrorComponent
  // Also handles [param] style (e.g., /blog/[slug] -> BlogSlugErrorComponent)
  let name = route.urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_')
    .replace(/\?/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'Index';

  // PascalCase
  name = name
    .split('_')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}ErrorComponent`;
}

function routeToPendingVarName(route: ScannedRoute): string {
  // Convert path like /posts/:postId to PostsPostIdPendingComponent
  // Also handles [param] style (e.g., /blog/[slug] -> BlogSlugPendingComponent)
  let name = route.urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_')
    .replace(/\?/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'Index';

  // PascalCase
  name = name
    .split('_')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}PendingComponent`;
}

function routeToMetaVarName(route: ScannedRoute): string {
  // Also handles [param] style (e.g., /blog/[slug] -> BlogSlugMeta)
  let name = route.urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_')
    .replace(/\?/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'Index';

  name = name
    .split('_')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}Meta`;
}

function routeToMiddlewareVarName(route: ScannedRoute): string {
  // Also handles [param] style (e.g., /blog/[slug] -> BlogSlugMiddleware)
  let name = route.urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_')
    .replace(/\?/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'Index';

  name = name
    .split('_')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}Middleware`;
}

function layoutToVarName(layout: LayoutRoute): string {
  // Convert scope path to PascalCase layout name
  // Also handles [param] style in layout paths
  let name = layout.scopePath
    .replace(/\//g, '_')
    .replace(/-/g, '_')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'Root';

  name = name
    .split('_')
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}Layout`;
}

function urlPathToFunctionName(urlPath: string): string {
  // Convert path like /posts/:postId to postsPostIdPath
  // Also handles [param] style (e.g., /blog/[slug] -> blogSlugPath)
  let name = urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_')
    .replace(/\?/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '');

  if (!name) name = 'index';

  // camelCase
  const parts = name.split('_');
  name = parts[0] + parts.slice(1).map((s) => s.charAt(0).toUpperCase() + s.slice(1)).join('');

  return `${name}Path`;
}

function generateParamsType(params: RouteParam[]): string {
  if (params.length === 0) return 'never';

  const entries = params.map((p) => `${p.name}: string`);
  return `{ ${entries.join('; ')} }`;
}

function getRelativeImportPath(fromDir: string, toFile: string): string {
  let rel = relative(fromDir, toFile);

  // Ensure it starts with ./
  if (!rel.startsWith('.')) {
    rel = './' + rel;
  }

  // Remove extension
  rel = rel.replace(/\.(tsx?|jsx?)$/, '');

  return rel;
}

/**
 * Generate a Rust-compatible route manifest
 */
export function generateRustManifest(tree: RouteTree): string {
  const routes = tree.apiRoutes.map((r) => ({
    path: r.urlPath,
    handler: pathToHandlerName(r.relativePath),
    methods: r.methods || ['GET'],
    params: r.params.map((p) => p.name),
  }));

  return JSON.stringify({ api_routes: routes }, null, 2);
}

function pathToHandlerName(relativePath: string): string {
  // Convert routes/api/users.[id].ts to api_users_id
  return relativePath
    .replace(/^routes\//, '')
    .replace(/\.(tsx?|jsx?)$/, '')
    .replace(/\//g, '_')
    .replace(/\$/g, '')
    .replace(/\[/g, '')
    .replace(/\]/g, '')
    .replace(/\./g, '_');
}

/**
 * Generate client-side router configuration
 * This provides the route definitions needed for client-side navigation
 */
function generateRouterConfig(tree: RouteTree, outputDir: string): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated client router configuration',
    ' * DO NOT EDIT MANUALLY',
    ' */',
    '',
    "import { lazy, type ComponentType } from 'react';",
    '',
  ];

  // Generate route interface
  lines.push('export interface RouteDefinition {');
  lines.push('  path: string;');
  lines.push('  pattern: RegExp;');
  lines.push('  paramNames: string[];');
  lines.push('  component: React.LazyExoticComponent<ComponentType<any>>;');
  lines.push('  isIndex: boolean;');
  lines.push('  layoutPath?: string;');
  lines.push('  errorComponent?: React.LazyExoticComponent<ComponentType<any>>;');
  lines.push('  pendingComponent?: React.LazyExoticComponent<ComponentType<any>>;');
  lines.push('}');
  lines.push('');

  // Generate component imports
  lines.push('// Route component imports');
  for (const route of tree.routes) {
    if (route.type !== 'page') continue;
    const varName = routeToVarName(route);
    const relativePath = getRelativeImportPath(outputDir, route.filePath);
    lines.push(`const ${varName} = lazy(() => import('${relativePath}'));`);

    if (route.hasErrorComponent) {
      const errorVarName = routeToErrorVarName(route);
      const exportName = route.errorComponentExport || 'errorComponent';
      lines.push(
        `const ${errorVarName} = lazy(() => import('${relativePath}').then(m => ({ default: m.${exportName} })));`
      );
    }

    if (route.hasPendingComponent) {
      const pendingVarName = routeToPendingVarName(route);
      const exportName = route.pendingComponentExport || 'pendingComponent';
      lines.push(
        `const ${pendingVarName} = lazy(() => import('${relativePath}').then(m => ({ default: m.${exportName} })));`
      );
    }
  }
  lines.push('');

  // Generate route pattern converter
  lines.push('/**');
  lines.push(' * Convert route path pattern to regex');
  lines.push(' * :param -> named capture group');
  lines.push(' * *param -> catch-all capture group');
  lines.push(' */');
  lines.push('function pathToRegex(path: string): { pattern: RegExp; paramNames: string[] } {');
  lines.push('  const paramNames: string[] = [];');
  lines.push('  let regexStr = path');
  lines.push("    .replace(/\\//g, '\\\\/')");
  lines.push("    .replace(/:\\w+\\??/g, (match) => {");
  lines.push("      const isOptional = match.endsWith('?');");
  lines.push("      const name = match.slice(1).replace('?', '');");
  lines.push('      paramNames.push(name);');
  lines.push("      return isOptional ? '([^/]*)?' : '([^/]+)';");
  lines.push('    })');
  lines.push("    .replace(/\\*\\w+\\??/g, (match) => {");
  lines.push("      const isOptional = match.endsWith('?');");
  lines.push("      const name = match.slice(1).replace('?', '');");
  lines.push('      paramNames.push(name);');
  lines.push("      return isOptional ? '(.*)?' : '(.+)';");
  lines.push('    });');
  lines.push("  return { pattern: new RegExp(`^${regexStr}$`), paramNames };");
  lines.push('}');
  lines.push('');

  // Generate routes array
  lines.push('// Route definitions with pre-compiled patterns');
  lines.push('export const routeDefinitions: RouteDefinition[] = [');

  for (const route of tree.routes) {
    if (route.type !== 'page') continue;
    const varName = routeToVarName(route);
    const { pattern, paramNames } = pathToRegexForCodegen(route.urlPath);

    lines.push('  {');
    lines.push(`    path: '${route.urlPath}',`);
    lines.push(`    pattern: ${pattern},`);
    lines.push(`    paramNames: ${JSON.stringify(paramNames)},`);
    lines.push(`    component: ${varName},`);
    lines.push(`    isIndex: ${route.isIndex},`);

    if (route.layoutPath) {
      const layout = tree.layouts.find(l => l.filePath === route.layoutPath);
      if (layout) {
        lines.push(`    layoutPath: '${layout.urlPath}',`);
      }
    }

    if (route.hasErrorComponent) {
      lines.push(`    errorComponent: ${routeToErrorVarName(route)},`);
    }

    if (route.hasPendingComponent) {
      lines.push(`    pendingComponent: ${routeToPendingVarName(route)},`);
    }

    lines.push('  },');
  }

  lines.push('];');
  lines.push('');

  // Generate path type
  const paths = tree.routes
    .filter(r => r.type === 'page')
    .map(r => `  | '${r.urlPath}'`);
  lines.push(`export type RoutePath =\n${paths.join('\n')};`);
  lines.push('');

  // Generate params type map
  lines.push('// Type-safe params for each route');
  lines.push('export interface RouteParams {');
  for (const route of tree.routes) {
    if (route.type !== 'page') continue;
    if (route.params.length === 0) {
      lines.push(`  '${route.urlPath}': Record<string, never>;`);
    } else {
      const params = route.params.map(p => `${p.name}: string`).join('; ');
      lines.push(`  '${route.urlPath}': { ${params} };`);
    }
  }
  lines.push('}');
  lines.push('');

  // Generate path builder functions
  lines.push('// Type-safe path builders');
  for (const route of tree.routes) {
    if (route.type !== 'page' || route.params.length === 0) continue;

    const fnName = urlPathToFunctionName(route.urlPath);
    const params = route.params
      .map(p => `${p.name}${p.optional ? '?' : ''}: string`)
      .join(', ');

    let template = route.urlPath;
    for (const param of route.params) {
      const optionalMarker = param.optional ? '?' : '';
      if (param.catchAll) {
        template = template.replace(`*${param.name}${optionalMarker}`, `\${${param.name} || ''}`);
      } else {
        template = template.replace(`:${param.name}${optionalMarker}`, `\${${param.name} || ''}`);
      }
    }

    lines.push(`export function ${fnName}(${params}): string {`);
    lines.push(`  return \`${template}\`.replace(/\\/+$/, '') || '/';`);
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Convert path pattern to regex at codegen time
 */
function pathToRegexForCodegen(path: string): { pattern: string; paramNames: string[] } {
  const paramNames: string[] = [];
  let regexStr = path
    .replace(/\//g, '\\/')
    .replace(/:\w+\??/g, (match) => {
      const isOptional = match.endsWith('?');
      const name = match.slice(1).replace('?', '');
      paramNames.push(name);
      return isOptional ? '([^/]*)?' : '([^/]+)';
    })
    .replace(/\*\w+\??/g, (match) => {
      const isOptional = match.endsWith('?');
      const name = match.slice(1).replace('?', '');
      paramNames.push(name);
      return isOptional ? '(.*)?' : '(.+)';
    });

  return { pattern: `/^${regexStr}$/`, paramNames };
}
