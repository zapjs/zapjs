/**
 * Route tree code generator
 *
 * Generates TypeScript files for:
 * - routeTree.ts - Route definitions and type-safe paths
 * - routeManifest.json - JSON manifest for Rust server
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, relative, dirname } from 'path';
import type {
  RouteTree,
  ScannedRoute,
  CodegenOptions,
  RouteManifest,
  RouteParam,
} from './types.js';

/**
 * Generate route tree TypeScript file and manifest
 */
export function generateRouteTree(options: CodegenOptions): void {
  const { outputDir, routeTree } = options;

  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Generate TypeScript route tree
  const tsContent = generateTypeScriptRouteTree(routeTree, outputDir);
  writeFileSync(join(outputDir, 'routeTree.ts'), tsContent);

  // Generate JSON manifest for Rust
  const manifest = generateManifest(routeTree);
  writeFileSync(join(outputDir, 'routeManifest.json'), JSON.stringify(manifest, null, 2));
}

function generateTypeScriptRouteTree(tree: RouteTree, outputDir: string): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated by @zapjs/router',
    ' * DO NOT EDIT MANUALLY',
    ' */',
    '',
    "import { lazy } from 'react';",
    '',
  ];

  // Generate route imports
  lines.push('// Route component imports');
  const imports = generateRouteImports(tree.routes, outputDir);
  lines.push(...imports);
  lines.push('');

  // Generate route path types
  lines.push('// Route path type definitions');
  lines.push(generatePathTypes(tree));
  lines.push('');

  // Generate route config
  lines.push('// Route configuration');
  lines.push(generateRouteConfig(tree));
  lines.push('');

  // Generate API route config
  if (tree.apiRoutes.length > 0) {
    lines.push('// API route configuration');
    lines.push(generateApiRouteConfig(tree));
    lines.push('');
  }

  // Generate helper functions
  lines.push('// Helper functions');
  lines.push(generateHelpers(tree));

  return lines.join('\n');
}

function generateRouteImports(routes: ScannedRoute[], outputDir: string): string[] {
  const lines: string[] = [];

  for (const route of routes) {
    if (route.type !== 'page') continue;

    const varName = routeToVarName(route);
    const relativePath = getRelativeImportPath(outputDir, route.filePath);

    lines.push(`const ${varName} = lazy(() => import('${relativePath}'));`);
  }

  return lines;
}

function generatePathTypes(tree: RouteTree): string {
  const allRoutes = [...tree.routes, ...tree.apiRoutes];
  const paths = allRoutes.map((r) => `  | '${r.urlPath}'`);

  return `export type RoutePath =\n${paths.join('\n')};`;
}

function generateRouteConfig(tree: RouteTree): string {
  const lines: string[] = ['export const routes = ['];

  for (const route of tree.routes) {
    if (route.type !== 'page') continue;

    const varName = routeToVarName(route);
    const paramsType = generateParamsType(route.params);

    lines.push('  {');
    lines.push(`    path: '${route.urlPath}',`);
    lines.push(`    component: ${varName},`);
    lines.push(`    isIndex: ${route.isIndex},`);

    if (route.params.length > 0) {
      lines.push(`    params: ${JSON.stringify(route.params.map((p) => p.name))},`);
    }

    lines.push('  },');
  }

  lines.push('] as const;');
  return lines.join('\n');
}

function generateApiRouteConfig(tree: RouteTree): string {
  const lines: string[] = ['export const apiRoutes = ['];

  for (const route of tree.apiRoutes) {
    lines.push('  {');
    lines.push(`    path: '${route.urlPath}',`);
    lines.push(`    filePath: '${route.relativePath}',`);
    lines.push(`    isIndex: ${route.isIndex},`);

    if (route.params.length > 0) {
      lines.push(`    params: ${JSON.stringify(route.params.map((p) => p.name))},`);
    }

    lines.push('  },');
  }

  lines.push('] as const;');
  return lines.join('\n');
}

function generateHelpers(tree: RouteTree): string {
  const allRoutes = [...tree.routes, ...tree.apiRoutes];

  // Build path helper function generators
  const pathHelpers: string[] = [];

  for (const route of allRoutes) {
    if (route.params.length === 0) continue;

    const fnName = urlPathToFunctionName(route.urlPath);
    const params = route.params.map((p) => `${p.name}: string`).join(', ');

    let template = route.urlPath;
    for (const param of route.params) {
      if (param.catchAll) {
        template = template.replace(`*${param.name}`, `\${${param.name}}`);
      } else {
        template = template.replace(`:${param.name}`, `\${${param.name}}`);
      }
    }

    pathHelpers.push(`export function ${fnName}(${params}): string {`);
    pathHelpers.push(`  return \`${template}\`;`);
    pathHelpers.push('}');
    pathHelpers.push('');
  }

  return pathHelpers.join('\n');
}

function generateManifest(tree: RouteTree): RouteManifest {
  return {
    version: '1.0.0',
    generatedAt: new Date().toISOString(),
    routes: tree.routes.map((r) => ({
      ...r,
      // Remove absolute paths for security
      filePath: r.relativePath,
    })),
    apiRoutes: tree.apiRoutes.map((r) => ({
      ...r,
      filePath: r.relativePath,
    })),
  };
}

function routeToVarName(route: ScannedRoute): string {
  // Convert path like /posts/:postId to PostsPostIdRoute
  let name = route.urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_');

  if (!name) name = 'Index';

  // PascalCase
  name = name
    .split('_')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');

  return `${name}Route`;
}

function urlPathToFunctionName(urlPath: string): string {
  // Convert path like /posts/:postId to postsPostIdPath
  let name = urlPath
    .replace(/^\//, '')
    .replace(/\//g, '_')
    .replace(/:/g, '')
    .replace(/\*/g, '')
    .replace(/-/g, '_');

  if (!name) name = 'index';

  // camelCase
  const parts = name.split('_');
  name = parts[0] + parts.slice(1).map((s) => s.charAt(0).toUpperCase() + s.slice(1)).join('');

  return `${name}Path`;
}

function generateParamsType(params: RouteParam[]): string {
  if (params.length === 0) return 'never';

  const entries = params.map((p) => `${p.name}: string`);
  return `{ ${entries.join('; ')} }`;
}

function getRelativeImportPath(fromDir: string, toFile: string): string {
  let rel = relative(fromDir, toFile);

  // Ensure it starts with ./
  if (!rel.startsWith('.')) {
    rel = './' + rel;
  }

  // Remove extension
  rel = rel.replace(/\.(tsx?|jsx?)$/, '');

  return rel;
}

/**
 * Generate a Rust-compatible route manifest
 */
export function generateRustManifest(tree: RouteTree): string {
  const routes = tree.apiRoutes.map((r) => ({
    path: r.urlPath,
    handler: pathToHandlerName(r.relativePath),
    methods: r.methods || ['GET'],
    params: r.params.map((p) => p.name),
  }));

  return JSON.stringify({ api_routes: routes }, null, 2);
}

function pathToHandlerName(relativePath: string): string {
  // Convert routes/api/users.$id.ts to api_users_id
  return relativePath
    .replace(/^routes\//, '')
    .replace(/\.(tsx?|jsx?)$/, '')
    .replace(/\//g, '_')
    .replace(/\$/g, '')
    .replace(/\./g, '_');
}
